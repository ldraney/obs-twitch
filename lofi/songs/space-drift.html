<!DOCTYPE html>
<html>
<head>
  <title>Space Drift - Cosmic Lofi Experience</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <script src="https://unpkg.com/tone@14"></script>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }

    html, body {
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: #050510;
      font-family: 'Consolas', 'Monaco', monospace;
    }

    #canvas {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 0;
    }

    /* Floating Controls Panel */
    .controls {
      position: fixed;
      top: 20px;
      left: 20px;
      z-index: 100;
      background: rgba(5, 5, 16, 0.85);
      border: 1px solid rgba(138, 100, 255, 0.2);
      border-radius: 12px;
      padding: 20px;
      min-width: 200px;
      backdrop-filter: blur(10px);
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
    }

    .title {
      color: #8a64ff;
      font-size: 18px;
      font-weight: bold;
      letter-spacing: 2px;
      margin-bottom: 15px;
      text-shadow: 0 0 20px rgba(138, 100, 255, 0.4);
    }

    .subtitle {
      color: #555;
      font-size: 11px;
      margin-bottom: 15px;
      font-style: italic;
    }

    .play-btn {
      width: 100%;
      padding: 14px 20px;
      font-size: 14px;
      font-weight: bold;
      text-transform: uppercase;
      letter-spacing: 2px;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.2s;
      font-family: inherit;
      background: linear-gradient(135deg, #8a64ff 0%, #6040cc 100%);
      color: #fff;
      box-shadow: 0 4px 20px rgba(138, 100, 255, 0.3);
    }

    .play-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 30px rgba(138, 100, 255, 0.5);
    }

    .play-btn.playing {
      background: linear-gradient(135deg, #ff6488 0%, #cc4060 100%);
      box-shadow: 0 4px 20px rgba(255, 100, 136, 0.4);
    }

    .control-row {
      margin-top: 15px;
    }

    .control-label {
      display: flex;
      justify-content: space-between;
      color: #555;
      font-size: 10px;
      text-transform: uppercase;
      letter-spacing: 1px;
      margin-bottom: 6px;
    }

    .control-value {
      color: #8a64ff;
      font-weight: bold;
    }

    input[type="range"] {
      width: 100%;
      height: 6px;
      -webkit-appearance: none;
      appearance: none;
      background: rgba(138, 100, 255, 0.1);
      border-radius: 3px;
      outline: none;
    }

    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 16px;
      height: 16px;
      background: #8a64ff;
      border-radius: 50%;
      cursor: pointer;
      box-shadow: 0 0 10px rgba(138, 100, 255, 0.5);
    }

    input[type="range"]::-moz-range-thumb {
      width: 16px;
      height: 16px;
      background: #8a64ff;
      border-radius: 50%;
      cursor: pointer;
      border: none;
      box-shadow: 0 0 10px rgba(138, 100, 255, 0.5);
    }

    /* Section Indicator */
    .section-indicator {
      margin-top: 20px;
      padding-top: 15px;
      border-top: 1px solid rgba(255, 255, 255, 0.05);
    }

    .current-section {
      font-size: 22px;
      font-weight: bold;
      text-transform: uppercase;
      letter-spacing: 4px;
      text-align: center;
      color: #8a64ff;
      text-shadow: 0 0 30px currentColor;
      transition: color 0.3s;
    }

    .section-time {
      text-align: center;
      color: #555;
      font-size: 11px;
      margin-top: 8px;
    }

    /* Timeline at bottom */
    .timeline {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      height: 50px;
      z-index: 100;
      background: linear-gradient(to top, rgba(5, 5, 16, 0.9), transparent);
      display: flex;
      align-items: flex-end;
      padding: 10px 20px;
    }

    .timeline-track {
      flex: 1;
      height: 30px;
      display: flex;
      border-radius: 6px;
      overflow: hidden;
      position: relative;
      box-shadow: inset 0 2px 8px rgba(0, 0, 0, 0.5);
    }

    .timeline-section {
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 9px;
      font-weight: bold;
      text-transform: uppercase;
      letter-spacing: 1px;
      cursor: pointer;
      transition: filter 0.2s, transform 0.1s;
      color: rgba(255, 255, 255, 0.8);
      border-right: 1px solid rgba(0, 0, 0, 0.3);
    }

    .timeline-section:last-child { border-right: none; }
    .timeline-section:hover { filter: brightness(1.3); }
    .timeline-section.active { filter: brightness(1.5); transform: scaleY(1.05); }

    .timeline-section.launch { background: linear-gradient(180deg, #1a1a3a, #0d0d20); }
    .timeline-section.orbit { background: linear-gradient(180deg, #2a1a4a, #1a1030); }
    .timeline-section.drift { background: linear-gradient(180deg, #4a2a6a, #301850); }
    .timeline-section.nebula { background: linear-gradient(180deg, #6a3a8a, #4a2060); }
    .timeline-section.void { background: linear-gradient(180deg, #2a2a4a, #1a1a30); }
    .timeline-section.return { background: linear-gradient(180deg, #1a1a3a, #0d0d20); }

    .playhead {
      position: absolute;
      width: 3px;
      height: 100%;
      background: #fff;
      box-shadow: 0 0 12px #fff;
      top: 0;
      left: 0;
      pointer-events: none;
      z-index: 10;
      border-radius: 2px;
    }

    /* Mobile adjustments */
    @media (max-width: 600px) {
      .controls {
        top: 10px;
        left: 10px;
        right: 10px;
        min-width: auto;
        padding: 15px;
      }

      .title { font-size: 14px; }
      .play-btn { padding: 12px 16px; font-size: 12px; }
      .timeline-section { font-size: 7px; }
    }

    .hint {
      position: fixed;
      bottom: 60px;
      left: 50%;
      transform: translateX(-50%);
      color: #333;
      font-size: 10px;
      text-transform: uppercase;
      letter-spacing: 2px;
      z-index: 50;
    }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>

  <div class="controls">
    <div class="title">Space Drift</div>
    <div class="subtitle">// cosmic lofi experience</div>

    <button id="playBtn" class="play-btn">Launch</button>

    <div class="control-row">
      <div class="control-label">
        <span>Volume</span>
        <span class="control-value" id="volVal">-12 dB</span>
      </div>
      <input type="range" id="volumeSlider" min="-30" max="0" value="-12">
    </div>

    <div class="control-row">
      <div class="control-label">
        <span>BPM</span>
        <span class="control-value" id="bpmVal">68</span>
      </div>
      <input type="range" id="bpmSlider" min="60" max="80" value="68">
    </div>

    <div class="section-indicator">
      <div class="current-section" id="currentSection">Ready</div>
      <div class="section-time" id="sectionTime">0:00 / 4:14</div>
    </div>
  </div>

  <div class="timeline">
    <div class="timeline-track" id="timeline">
      <div class="playhead" id="playhead"></div>
    </div>
  </div>

  <div class="hint">Click timeline to jump</div>

  <script>
    // ============================================================================
    // UTILITY FUNCTIONS
    // ============================================================================

    function lerp(current, target, factor) {
      return current + (target - current) * factor;
    }

    function map(value, inMin, inMax, outMin, outMax) {
      return ((value - inMin) / (inMax - inMin)) * (outMax - outMin) + outMin;
    }

    function clamp(value, min, max) {
      return Math.min(Math.max(value, min), max);
    }

    function createSmoother(factor = 0.1) {
      let value = null;
      return function smooth(target) {
        if (value === null) value = target;
        else value = lerp(value, target, factor);
        return value;
      };
    }

    // ============================================================================
    // GLOBAL STATE
    // ============================================================================

    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');

    let isInitialized = false;
    let isPlaying = false;
    let currentSectionIndex = 0;

    // Audio nodes
    let masterFilter, reverb, delay, compressor;
    let kick, snare, hihat;
    let pad, bass, arpeggio, atmosphereSynth;
    let spaceNoise, noiseFilter;
    let filterLFO, padLFO;
    let drumLoop, padLoop, bassLoop, arpLoop, atmosphereLoop;

    // Audio analyzers
    let fft, meter;

    // Song structure (72 bars @ 68 BPM = ~4:14)
    const songStructure = [
      { name: 'launch', startBar: 0, bars: 8, label: 'Launch', color: '#3a3a6a' },
      { name: 'orbit', startBar: 8, bars: 12, label: 'Orbit', color: '#5a3a8a' },
      { name: 'drift', startBar: 20, bars: 16, label: 'Drift', color: '#7a4aaa' },
      { name: 'nebula', startBar: 36, bars: 16, label: 'Nebula', color: '#9a5aca' },
      { name: 'void', startBar: 52, bars: 12, label: 'Void', color: '#4a4a7a' },
      { name: 'return', startBar: 64, bars: 8, label: 'Return', color: '#3a3a6a' }
    ];
    const totalBars = 72;

    // Section configurations
    const sectionConfigs = {
      launch: {
        noise: true, pad: true, kick: false, snare: false, bass: false, arp: false, atmos: true,
        filterFreq: 300, reverbWet: 0.8, padVol: -20, arpVol: -Infinity
      },
      orbit: {
        noise: true, pad: true, kick: true, snare: false, bass: true, arp: false, atmos: true,
        filterFreq: 600, reverbWet: 0.7, padVol: -14, arpVol: -Infinity
      },
      drift: {
        noise: true, pad: true, kick: true, snare: true, bass: true, arp: true, atmos: true,
        filterFreq: 1200, reverbWet: 0.6, padVol: -10, arpVol: -16
      },
      nebula: {
        noise: true, pad: true, kick: true, snare: true, bass: true, arp: true, atmos: true,
        filterFreq: 1800, reverbWet: 0.5, padVol: -8, arpVol: -12
      },
      void: {
        noise: true, pad: true, kick: false, snare: false, bass: false, arp: false, atmos: true,
        filterFreq: 400, reverbWet: 0.85, padVol: -16, arpVol: -Infinity
      },
      return: {
        noise: true, pad: true, kick: false, snare: false, bass: false, arp: false, atmos: true,
        filterFreq: 250, reverbWet: 0.9, padVol: -22, arpVol: -Infinity
      }
    };

    // ============================================================================
    // STAR FIELD
    // ============================================================================

    const STAR_LAYERS = 3;
    const STARS_PER_LAYER = [200, 150, 100]; // Back to front
    const STAR_SPEEDS = [0.1, 0.3, 0.6];
    const STAR_SIZES = [1, 1.5, 2.5];
    let starLayers = [];

    // Shooting stars
    let shootingStars = [];
    const MAX_SHOOTING_STARS = 5;

    // Nebula particles
    let nebulaParticles = [];
    const NEBULA_PARTICLE_COUNT = 30;

    // Aurora waves
    let auroraPhase = 0;

    // Smoothers
    const smoothers = {
      rms: createSmoother(0.12),
      bass: createSmoother(0.15),
      mid: createSmoother(0.1),
      high: createSmoother(0.2),
      bands: Array.from({ length: 8 }, () => createSmoother(0.15)),
    };

    // Visual state
    let cosmicHue = 260; // Purple base
    let pulseIntensity = 0;
    let prevRms = 0;

    // ============================================================================
    // CANVAS SETUP
    // ============================================================================

    function resize() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      initStarField();
      initNebulaParticles();
    }

    window.addEventListener('resize', resize);
    resize();

    function initStarField() {
      starLayers = [];
      for (let layer = 0; layer < STAR_LAYERS; layer++) {
        const stars = [];
        for (let i = 0; i < STARS_PER_LAYER[layer]; i++) {
          stars.push({
            x: Math.random() * canvas.width,
            y: Math.random() * canvas.height,
            twinklePhase: Math.random() * Math.PI * 2,
            twinkleSpeed: 0.02 + Math.random() * 0.03,
            baseAlpha: 0.3 + Math.random() * 0.7
          });
        }
        starLayers.push(stars);
      }
    }

    function initNebulaParticles() {
      nebulaParticles = [];
      for (let i = 0; i < NEBULA_PARTICLE_COUNT; i++) {
        nebulaParticles.push({
          x: Math.random() * canvas.width,
          y: Math.random() * canvas.height,
          radius: 50 + Math.random() * 150,
          hue: 240 + Math.random() * 60, // Purple to magenta
          alpha: 0.02 + Math.random() * 0.03,
          driftX: (Math.random() - 0.5) * 0.2,
          driftY: (Math.random() - 0.5) * 0.1
        });
      }
    }

    // ============================================================================
    // AUDIO INITIALIZATION
    // ============================================================================

    async function initAudio() {
      if (isInitialized) return;

      await Tone.start();

      Tone.Transport.bpm.value = 68;
      Tone.Transport.swing = 0.08;
      Tone.Transport.swingSubdivision = '16n';

      // Compressor
      compressor = new Tone.Compressor({
        threshold: -24,
        ratio: 3,
        attack: 0.01,
        release: 0.3
      }).toDestination();

      // Master filter (darker, more muffled for space)
      masterFilter = new Tone.Filter({
        frequency: 800,
        type: 'lowpass',
        rolloff: -24,
        Q: 0.8
      }).connect(compressor);

      // Filter LFO (very slow, cosmic breathing)
      filterLFO = new Tone.LFO({
        frequency: 0.05,
        min: 400,
        max: 1200,
        type: 'sine'
      });

      // Huge reverb (space is vast)
      reverb = new Tone.Reverb({ decay: 8, wet: 0.7 });
      await reverb.generate();
      reverb.connect(masterFilter);

      // Long delay (echoes in the void)
      delay = new Tone.FeedbackDelay('8n.', 0.4);
      delay.wet.value = 0.25;
      delay.connect(masterFilter);

      // Audio analyzers
      fft = new Tone.FFT(256);
      meter = new Tone.Meter();
      Tone.Destination.connect(fft);
      Tone.Destination.connect(meter);

      // Space noise (filtered white noise - radio static)
      noiseFilter = new Tone.Filter(800, 'bandpass').connect(compressor);
      spaceNoise = new Tone.Noise('white');
      spaceNoise.connect(noiseFilter);
      spaceNoise.volume.value = -32;

      // Soft kick (distant, subby)
      kick = new Tone.MembraneSynth({
        pitchDecay: 0.08,
        octaves: 4,
        oscillator: { type: 'sine' },
        envelope: { attack: 0.01, decay: 0.4, sustain: 0, release: 0.4 }
      }).connect(masterFilter);
      kick.volume.value = -Infinity;

      // Soft snare (rimshot-like, distant)
      snare = new Tone.NoiseSynth({
        noise: { type: 'pink' },
        envelope: { attack: 0.005, decay: 0.15, sustain: 0, release: 0.1 }
      }).connect(reverb);
      snare.volume.value = -Infinity;

      // Sparkly hi-hat (twinkling stars)
      hihat = new Tone.MetalSynth({
        frequency: 300,
        envelope: { attack: 0.001, decay: 0.08, release: 0.02 },
        harmonicity: 6,
        modulationIndex: 20,
        resonance: 5000,
        octaves: 1.2
      }).connect(reverb);
      hihat.volume.value = -Infinity;

      // Ethereal pad (detuned, wide)
      pad = new Tone.PolySynth(Tone.Synth, {
        oscillator: { type: 'sine' },
        envelope: { attack: 1.5, decay: 2, sustain: 0.7, release: 3 }
      });

      // Add chorus for width
      const chorus = new Tone.Chorus({
        frequency: 0.3,
        delayTime: 3.5,
        depth: 0.7,
        wet: 0.5
      }).connect(reverb);
      await chorus.start();
      pad.connect(chorus);
      pad.volume.value = -18;

      // Pad detune LFO
      padLFO = new Tone.LFO({
        frequency: 0.08,
        min: -15,
        max: 15,
        type: 'sine'
      });

      // Deep bass
      bass = new Tone.Synth({
        oscillator: { type: 'sine' },
        envelope: { attack: 0.1, decay: 0.3, sustain: 0.6, release: 0.5 }
      }).connect(masterFilter);
      bass.volume.value = -Infinity;

      // Twinkling arpeggio (stars)
      arpeggio = new Tone.Synth({
        oscillator: { type: 'triangle' },
        envelope: { attack: 0.02, decay: 0.3, sustain: 0.1, release: 0.8 }
      }).connect(delay).connect(reverb);
      arpeggio.volume.value = -Infinity;

      // Atmosphere synth (low drone)
      atmosphereSynth = new Tone.Synth({
        oscillator: { type: 'sine' },
        envelope: { attack: 4, decay: 2, sustain: 0.8, release: 5 }
      }).connect(reverb);
      atmosphereSynth.volume.value = -26;

      createPatterns();
      scheduleStructure();
      buildTimeline();

      // Set initial volume to match slider default (80% loudness)
      Tone.Destination.volume.value = -12;

      isInitialized = true;
    }

    // ============================================================================
    // PATTERNS
    // ============================================================================

    function createPatterns() {
      // Minimal drum loop
      drumLoop = new Tone.Loop((time) => {
        const bar = parseInt(Tone.Transport.position.split(':')[0]);
        const beat = parseInt(Tone.Transport.position.split(':')[1]);
        const sixteenth = Math.floor(parseFloat(Tone.Transport.position.split(':')[2]) / 0.25);

        const humanize = () => (Math.random() - 0.5) * 0.02;
        const velVar = () => 0.7 + Math.random() * 0.3;

        // Sparse kick: beat 1 and sometimes beat 3
        if (beat === 0 && sixteenth === 0) {
          kick.triggerAttackRelease('C1', '2n', time + humanize(), velVar());
        }
        if (beat === 2 && sixteenth === 0 && Math.random() > 0.3) {
          kick.triggerAttackRelease('C1', '4n', time + humanize(), velVar() * 0.7);
        }

        // Soft snare on 3 (not every bar)
        if (beat === 2 && sixteenth === 0 && bar % 2 === 1) {
          snare.triggerAttackRelease('8n', time + humanize(), velVar() * 0.6);
        }

        // Twinkling hi-hats (random, sparse)
        if (sixteenth % 2 === 0 && Math.random() > 0.6) {
          const vel = 0.2 + Math.random() * 0.3;
          hihat.triggerAttackRelease('32n', time + humanize(), vel);

          // Trigger shooting star on hi-hat
          if (Math.random() > 0.7) {
            spawnShootingStar();
          }
        }
      }, '16n');

      // Ethereal pad progression (space chords)
      const padChords = [
        { notes: ['C3', 'G3', 'D4', 'A4'] },      // Cmaj9 voicing
        { notes: ['A2', 'E3', 'B3', 'F#4'] },     // Am9
        { notes: ['F2', 'C3', 'G3', 'D4'] },      // Fmaj9
        { notes: ['G2', 'D3', 'A3', 'E4'] }       // G9
      ];
      let padIndex = 0;

      padLoop = new Tone.Loop((time) => {
        const chord = padChords[padIndex % 4];
        // Slight random detune for each note
        const detunedNotes = chord.notes.map(n => n);
        pad.triggerAttackRelease(detunedNotes, '1m', time + (Math.random() - 0.5) * 0.1, 0.4 + Math.random() * 0.2);
        padIndex++;
      }, '1m');

      // Deep bass (follows root of chords)
      const bassNotes = ['C1', 'A0', 'F1', 'G1'];
      let bassIndex = 0;

      bassLoop = new Tone.Loop((time) => {
        const note = bassNotes[bassIndex % 4];
        bass.triggerAttackRelease(note, '1m', time + (Math.random() - 0.5) * 0.03, 0.6 + Math.random() * 0.2);
        bassIndex++;
      }, '1m');

      // Twinkling arpeggio (pentatonic, random rhythm)
      const arpNotes = ['C5', 'D5', 'E5', 'G5', 'A5', 'C6', 'D6', 'E6'];

      arpLoop = new Tone.Loop((time) => {
        if (Math.random() > 0.5) {
          const note = arpNotes[Math.floor(Math.random() * arpNotes.length)];
          const vel = 0.3 + Math.random() * 0.4;
          arpeggio.triggerAttackRelease(note, '8n', time + (Math.random() - 0.5) * 0.04, vel);
        }
      }, '8n');

      // Atmosphere drone
      atmosphereLoop = new Tone.Loop((time) => {
        // Very low drone that shifts occasionally
        const droneNotes = ['C1', 'G0', 'F1'];
        const note = droneNotes[Math.floor(Math.random() * droneNotes.length)];
        atmosphereSynth.triggerAttackRelease(note, '4m', time, 0.3);
      }, '4m');
    }

    function spawnShootingStar() {
      if (shootingStars.length >= MAX_SHOOTING_STARS) return;

      shootingStars.push({
        x: Math.random() * canvas.width,
        y: Math.random() * canvas.height * 0.5,
        vx: 8 + Math.random() * 8,
        vy: 4 + Math.random() * 4,
        life: 1,
        length: 30 + Math.random() * 50
      });
    }

    // ============================================================================
    // SONG STRUCTURE
    // ============================================================================

    function scheduleStructure() {
      Tone.Transport.cancel();

      songStructure.forEach((section, index) => {
        Tone.Transport.schedule((time) => {
          currentSectionIndex = index;
          applySection(section.name, time);
          Tone.Draw.schedule(() => updateSectionDisplay(section, index), time);
        }, `${section.startBar}:0:0`);
      });

      // Filter automations for journey
      Tone.Transport.schedule((time) => {
        masterFilter.frequency.exponentialRampTo(600, 8, time);
      }, '6:0:0');

      Tone.Transport.schedule((time) => {
        masterFilter.frequency.exponentialRampTo(1200, 12, time);
      }, '16:0:0');

      Tone.Transport.schedule((time) => {
        masterFilter.frequency.exponentialRampTo(1800, 8, time);
      }, '32:0:0');

      Tone.Transport.schedule((time) => {
        masterFilter.frequency.exponentialRampTo(400, 6, time);
      }, '50:0:0');

      Tone.Transport.schedule((time) => {
        masterFilter.frequency.exponentialRampTo(250, 8, time);
        pad.volume.rampTo(-30, 8, time);
      }, '64:0:0');

      // Enable native looping
      Tone.Transport.loop = true;
      Tone.Transport.loopStart = 0;
      Tone.Transport.loopEnd = `${totalBars}:0:0`;
    }

    function applySection(name, time) {
      const config = sectionConfigs[name];
      const rampTime = 0.6;

      masterFilter.frequency.rampTo(config.filterFreq, rampTime, time);
      reverb.wet.rampTo(config.reverbWet, rampTime, time);

      kick.volume.rampTo(config.kick ? -10 : -Infinity, 0.4, time);
      snare.volume.rampTo(config.snare ? -14 : -Infinity, 0.4, time);
      hihat.volume.rampTo(config.kick ? -20 : -Infinity, 0.4, time);
      bass.volume.rampTo(config.bass ? -8 : -Infinity, 0.4, time);
      pad.volume.rampTo(config.padVol, 0.4, time);
      arpeggio.volume.rampTo(config.arpVol, 0.4, time);
      atmosphereSynth.volume.rampTo(config.atmos ? -26 : -Infinity, 0.4, time);
    }

    function updateSectionDisplay(section, index) {
      const el = document.getElementById('currentSection');
      el.textContent = section.label;
      el.style.color = section.color;

      document.querySelectorAll('.timeline-section').forEach((s, i) => {
        s.classList.toggle('active', i === index);
      });
    }

    // ============================================================================
    // TIMELINE
    // ============================================================================

    function buildTimeline() {
      const timeline = document.getElementById('timeline');
      timeline.innerHTML = '<div class="playhead" id="playhead"></div>';

      songStructure.forEach((section, index) => {
        const div = document.createElement('div');
        div.className = `timeline-section ${section.name}`;
        div.style.width = `${(section.bars / totalBars) * 100}%`;
        div.textContent = section.label;
        div.addEventListener('click', () => jumpToSection(index));
        timeline.appendChild(div);
      });
    }

    function jumpToSection(index) {
      if (!isInitialized) return;

      const section = songStructure[index];
      currentSectionIndex = index;
      Tone.Transport.position = `${section.startBar}:0:0`;
      applySection(section.name, Tone.now());
      updateSectionDisplay(section, index);

      if (!isPlaying) startPlayback();
    }

    // ============================================================================
    // PLAYBACK
    // ============================================================================

    async function startPlayback() {
      if (!isInitialized) await initAudio();
      if (isPlaying) return;

      drumLoop.start(0);
      padLoop.start(0);
      bassLoop.start(0);
      arpLoop.start(0);
      atmosphereLoop.start(0);
      spaceNoise.start();
      filterLFO.start();
      padLFO.start();

      Tone.Transport.start();
      isPlaying = true;

      document.getElementById('playBtn').textContent = 'Stop';
      document.getElementById('playBtn').classList.add('playing');
    }

    function stopPlayback() {
      drumLoop.stop();
      padLoop.stop();
      bassLoop.stop();
      arpLoop.stop();
      atmosphereLoop.stop();
      spaceNoise.stop();
      filterLFO.stop();
      padLFO.stop();

      Tone.Transport.stop();
      Tone.Transport.position = 0;
      isPlaying = false;
      currentSectionIndex = 0;

      document.getElementById('playBtn').textContent = 'Launch';
      document.getElementById('playBtn').classList.remove('playing');
      document.getElementById('currentSection').textContent = 'Ready';
      document.getElementById('currentSection').style.color = '#8a64ff';
      document.getElementById('playhead').style.left = '0%';
    }

    // ============================================================================
    // AUDIO ANALYSIS
    // ============================================================================

    function getAudioFeatures() {
      if (!fft || !meter) {
        return { bands: new Array(8).fill(0), rms: 0, bass: 0, mid: 0, high: 0 };
      }

      const fftValues = fft.getValue();
      const rmsDb = meter.getValue();
      const rms = clamp(map(rmsDb, -60, -6, 0, 1), 0, 1);

      const numBins = fftValues.length;
      const bandsPerGroup = Math.floor(numBins / 8);
      const bands = [];

      for (let i = 0; i < 8; i++) {
        const start = i * bandsPerGroup;
        const end = Math.min(start + bandsPerGroup, numBins);
        let sum = 0;
        for (let j = start; j < end; j++) {
          const linear = clamp(map(fftValues[j], -100, -20, 0, 1), 0, 1);
          sum += linear;
        }
        bands.push(sum / (end - start));
      }

      const bass = (bands[0] + bands[1]) / 2;
      const mid = (bands[2] + bands[3] + bands[4]) / 3;
      const high = (bands[5] + bands[6] + bands[7]) / 3;

      return { bands, rms, bass, mid, high };
    }

    // ============================================================================
    // DRAWING
    // ============================================================================

    function drawBackground(width, height, smoothedRms, smoothedBass) {
      // Deep space gradient
      const gradient = ctx.createRadialGradient(
        width / 2, height / 2, 0,
        width / 2, height / 2, Math.max(width, height) * 0.8
      );

      const pulseAmount = smoothedBass * 0.15;
      const baseLightness = 3 + pulseAmount * 5;

      gradient.addColorStop(0, `hsl(${cosmicHue + 20}, 40%, ${baseLightness + 3}%)`);
      gradient.addColorStop(0.5, `hsl(${cosmicHue}, 30%, ${baseLightness}%)`);
      gradient.addColorStop(1, `hsl(${cosmicHue - 20}, 25%, ${baseLightness - 1}%)`);

      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, width, height);
    }

    function drawNebulaParticles(width, height, smoothedMid) {
      nebulaParticles.forEach(particle => {
        // Drift slowly
        particle.x += particle.driftX;
        particle.y += particle.driftY;

        // Wrap around
        if (particle.x < -particle.radius) particle.x = width + particle.radius;
        if (particle.x > width + particle.radius) particle.x = -particle.radius;
        if (particle.y < -particle.radius) particle.y = height + particle.radius;
        if (particle.y > height + particle.radius) particle.y = -particle.radius;

        // Draw nebula cloud
        const gradient = ctx.createRadialGradient(
          particle.x, particle.y, 0,
          particle.x, particle.y, particle.radius
        );

        const alpha = particle.alpha * (0.8 + smoothedMid * 0.5);
        gradient.addColorStop(0, `hsla(${particle.hue}, 60%, 40%, ${alpha})`);
        gradient.addColorStop(0.5, `hsla(${particle.hue + 20}, 50%, 30%, ${alpha * 0.5})`);
        gradient.addColorStop(1, 'transparent');

        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(particle.x, particle.y, particle.radius, 0, Math.PI * 2);
        ctx.fill();
      });
    }

    function drawAurora(width, height, smoothedBands, time) {
      auroraPhase += 0.005;

      const auroraY = height * 0.3;
      const amplitude = 50 + smoothedBands[2] * 100;

      ctx.globalAlpha = 0.15 + smoothedBands[3] * 0.2;

      for (let wave = 0; wave < 3; wave++) {
        const waveHue = cosmicHue + wave * 30 + 120; // Greens and cyans
        const waveOffset = wave * 0.5;

        ctx.beginPath();
        ctx.moveTo(0, auroraY);

        for (let x = 0; x <= width; x += 5) {
          const y = auroraY +
            Math.sin((x * 0.005) + auroraPhase + waveOffset) * amplitude +
            Math.sin((x * 0.01) + auroraPhase * 1.5) * amplitude * 0.5;
          ctx.lineTo(x, y);
        }

        ctx.lineTo(width, 0);
        ctx.lineTo(0, 0);
        ctx.closePath();

        const gradient = ctx.createLinearGradient(0, auroraY - amplitude, 0, 0);
        gradient.addColorStop(0, `hsla(${waveHue}, 70%, 50%, 0.3)`);
        gradient.addColorStop(1, 'transparent');
        ctx.fillStyle = gradient;
        ctx.fill();
      }

      ctx.globalAlpha = 1;
    }

    function drawStarField(width, height, smoothedRms, dt) {
      starLayers.forEach((stars, layerIndex) => {
        const speed = STAR_SPEEDS[layerIndex];
        const size = STAR_SIZES[layerIndex];

        stars.forEach(star => {
          // Parallax movement (subtle drift)
          star.x -= speed * dt * 60 * (0.5 + smoothedRms * 0.5);
          if (star.x < 0) {
            star.x = width;
            star.y = Math.random() * height;
          }

          // Twinkle
          star.twinklePhase += star.twinkleSpeed;
          const twinkle = 0.5 + Math.sin(star.twinklePhase) * 0.5;
          const alpha = star.baseAlpha * twinkle * (0.6 + smoothedRms * 0.4);

          // Draw star with glow
          const starSize = size * (0.8 + smoothedRms * 0.4);

          // Glow
          ctx.beginPath();
          ctx.arc(star.x, star.y, starSize * 3, 0, Math.PI * 2);
          ctx.fillStyle = `rgba(200, 180, 255, ${alpha * 0.1})`;
          ctx.fill();

          // Core
          ctx.beginPath();
          ctx.arc(star.x, star.y, starSize, 0, Math.PI * 2);
          ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;
          ctx.fill();
        });
      });
    }

    function drawShootingStars(width, height, dt) {
      shootingStars = shootingStars.filter(star => {
        star.x += star.vx * dt * 60;
        star.y += star.vy * dt * 60;
        star.life -= dt * 1.5;

        if (star.life <= 0 || star.x > width || star.y > height) {
          return false;
        }

        // Draw trail
        const gradient = ctx.createLinearGradient(
          star.x, star.y,
          star.x - star.vx * star.length / star.vx,
          star.y - star.vy * star.length / star.vy
        );

        gradient.addColorStop(0, `rgba(255, 255, 255, ${star.life})`);
        gradient.addColorStop(1, 'transparent');

        ctx.strokeStyle = gradient;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(star.x, star.y);
        ctx.lineTo(
          star.x - (star.vx / Math.abs(star.vx)) * star.length * star.life,
          star.y - (star.vy / Math.abs(star.vy)) * star.length * 0.5 * star.life
        );
        ctx.stroke();

        // Draw head
        ctx.beginPath();
        ctx.arc(star.x, star.y, 2, 0, Math.PI * 2);
        ctx.fillStyle = `rgba(255, 255, 255, ${star.life})`;
        ctx.fill();

        return true;
      });
    }

    function drawCentralGlow(width, height, smoothedRms, smoothedBass) {
      // Pulsing central glow (like a distant star or the sun)
      const centerX = width / 2;
      const centerY = height * 0.4;
      const baseRadius = 100 + smoothedBass * 150;
      const pulseRadius = baseRadius * (1 + pulseIntensity * 0.3);

      const gradient = ctx.createRadialGradient(
        centerX, centerY, 0,
        centerX, centerY, pulseRadius
      );

      const glowAlpha = 0.1 + smoothedRms * 0.15;
      gradient.addColorStop(0, `hsla(${cosmicHue + 60}, 50%, 70%, ${glowAlpha})`);
      gradient.addColorStop(0.3, `hsla(${cosmicHue + 40}, 40%, 50%, ${glowAlpha * 0.5})`);
      gradient.addColorStop(1, 'transparent');

      ctx.fillStyle = gradient;
      ctx.beginPath();
      ctx.arc(centerX, centerY, pulseRadius, 0, Math.PI * 2);
      ctx.fill();
    }

    // ============================================================================
    // RENDER LOOP
    // ============================================================================

    let lastTime = performance.now();

    function render() {
      const now = performance.now();
      const dt = Math.min((now - lastTime) / 1000, 0.05);
      lastTime = now;

      const { width, height } = canvas;

      // Get audio features
      const audioFeatures = getAudioFeatures();

      // Smooth features
      const smoothedRms = smoothers.rms(audioFeatures.rms);
      const smoothedBass = smoothers.bass(audioFeatures.bass);
      const smoothedMid = smoothers.mid(audioFeatures.mid);
      const smoothedHigh = smoothers.high(audioFeatures.high);
      const smoothedBands = audioFeatures.bands.map((b, i) => smoothers.bands[i](b));

      // Detect bass hits for pulse
      const rmsDelta = smoothedRms - prevRms;
      if (rmsDelta > 0.03) {
        pulseIntensity = Math.max(pulseIntensity, rmsDelta * 8);
      }
      pulseIntensity *= 0.94;
      prevRms = smoothedRms;

      // Update cosmic hue slowly (drifting through purples/blues)
      cosmicHue = 260 + Math.sin(now * 0.0001) * 30;

      // ========================================================================
      // DRAWING LAYERS
      // ========================================================================

      // 1. Deep space background
      drawBackground(width, height, smoothedRms, smoothedBass);

      // 2. Nebula clouds (behind stars)
      drawNebulaParticles(width, height, smoothedMid);

      // 3. Aurora waves (mid layer)
      drawAurora(width, height, smoothedBands, now);

      // 4. Central glow
      drawCentralGlow(width, height, smoothedRms, smoothedBass);

      // 5. Star field (parallax layers)
      drawStarField(width, height, smoothedRms, dt);

      // 6. Shooting stars (on top)
      drawShootingStars(width, height, dt);

      // 7. Bass pulse overlay
      if (pulseIntensity > 0.1) {
        const pulseGradient = ctx.createRadialGradient(
          width / 2, height / 2, 0,
          width / 2, height / 2, Math.max(width, height)
        );
        pulseGradient.addColorStop(0, `rgba(138, 100, 255, ${pulseIntensity * 0.1})`);
        pulseGradient.addColorStop(1, 'transparent');
        ctx.fillStyle = pulseGradient;
        ctx.fillRect(0, 0, width, height);
      }

      // Update UI
      if (isPlaying) {
        updateProgress();
      }

      requestAnimationFrame(render);
    }

    function updateProgress() {
      const position = Tone.Transport.position;
      const parts = position.split(':');
      const bar = parseInt(parts[0]);
      const beat = parseInt(parts[1]);
      const progressBars = bar + beat / 4;
      const percent = (progressBars / totalBars) * 100;

      document.getElementById('playhead').style.left = `${Math.min(percent, 100)}%`;

      const bpm = Tone.Transport.bpm.value;
      const secondsPerBar = (60 / bpm) * 4;
      const currentSeconds = progressBars * secondsPerBar;
      const totalSeconds = totalBars * secondsPerBar;

      const formatTime = (s) => {
        const m = Math.floor(s / 60);
        const sec = Math.floor(s % 60).toString().padStart(2, '0');
        return `${m}:${sec}`;
      };

      document.getElementById('sectionTime').textContent =
        `${formatTime(currentSeconds)} / ${formatTime(totalSeconds)}`;
    }

    // ============================================================================
    // EVENT LISTENERS
    // ============================================================================

    document.getElementById('playBtn').addEventListener('click', async () => {
      if (isPlaying) {
        stopPlayback();
      } else {
        if (!isInitialized) await initAudio();
        Tone.Transport.position = 0;
        currentSectionIndex = 0;
        applySection('launch', Tone.now());
        updateSectionDisplay(songStructure[0], 0);
        startPlayback();
      }
    });

    document.getElementById('volumeSlider').addEventListener('input', (e) => {
      const vol = parseFloat(e.target.value);
      Tone.Destination.volume.value = vol;
      document.getElementById('volVal').textContent = `${vol} dB`;
    });

    document.getElementById('bpmSlider').addEventListener('input', (e) => {
      const val = parseInt(e.target.value);
      document.getElementById('bpmVal').textContent = val;
      Tone.Transport.bpm.value = val;
    });

    // Keyboard shortcuts
    document.addEventListener('keydown', async (e) => {
      if (e.key === ' ') {
        e.preventDefault();
        if (isPlaying) {
          stopPlayback();
        } else {
          if (!isInitialized) await initAudio();
          Tone.Transport.position = 0;
          applySection('launch', Tone.now());
          updateSectionDisplay(songStructure[0], 0);
          startPlayback();
        }
      }

      const num = parseInt(e.key);
      if (num >= 1 && num <= 6 && isInitialized) {
        jumpToSection(num - 1);
      }
    });

    // Touch support
    canvas.addEventListener('touchstart', async (e) => {
      if (!isPlaying) {
        e.preventDefault();
        if (!isInitialized) await initAudio();
        Tone.Transport.position = 0;
        applySection('launch', Tone.now());
        updateSectionDisplay(songStructure[0], 0);
        startPlayback();
      }
    }, { passive: false });

    // Build initial timeline
    function buildInitialTimeline() {
      const timeline = document.getElementById('timeline');
      timeline.innerHTML = '<div class="playhead" id="playhead"></div>';

      songStructure.forEach((section) => {
        const div = document.createElement('div');
        div.className = `timeline-section ${section.name}`;
        div.style.width = `${(section.bars / totalBars) * 100}%`;
        div.textContent = section.label;
        timeline.appendChild(div);
      });
    }

    buildInitialTimeline();

    // Cleanup
    window.addEventListener('beforeunload', () => {
      if (isPlaying) stopPlayback();
    });

    // Start render loop
    render();
  </script>
</body>
</html>
