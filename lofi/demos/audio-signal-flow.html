<!DOCTYPE html>
<html>
<head>
  <title>Audio Signal Flow - Demo</title>
  <script src="https://unpkg.com/tone@14"></script>
  <style>
    * { box-sizing: border-box; }
    body {
      background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
      color: #eee;
      font-family: 'Segoe UI', sans-serif;
      min-height: 100vh;
      margin: 0;
      padding: 20px;
    }
    .container { max-width: 1000px; margin: 0 auto; }
    h1 { color: #e94560; margin-bottom: 10px; }
    h2 { color: #4ecdc4; margin-top: 30px; margin-bottom: 15px; }
    .subtitle { color: #888; margin-bottom: 30px; }

    .section {
      background: rgba(255,255,255,0.05);
      border-radius: 12px;
      padding: 20px;
      margin: 20px 0;
    }

    .signal-chain {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 20px;
      background: rgba(0,0,0,0.3);
      border-radius: 8px;
      overflow-x: auto;
      min-height: 120px;
    }

    .node {
      background: #2a2a4e;
      border: 2px solid #4ecdc4;
      border-radius: 8px;
      padding: 15px;
      min-width: 120px;
      text-align: center;
      cursor: grab;
      user-select: none;
      transition: all 0.2s;
    }
    .node:hover { border-color: #e94560; transform: scale(1.02); }
    .node.dragging { opacity: 0.5; cursor: grabbing; }
    .node.source { border-color: #e94560; background: rgba(233, 69, 96, 0.2); }
    .node.output { border-color: #4ecdc4; background: rgba(78, 205, 196, 0.2); cursor: default; }
    .node .name { font-weight: bold; margin-bottom: 5px; }
    .node .type { font-size: 11px; color: #888; }

    .arrow {
      color: #4ecdc4;
      font-size: 24px;
      flex-shrink: 0;
    }

    .effect-params {
      margin-top: 10px;
      font-size: 12px;
    }
    .effect-params input {
      width: 80px;
      background: rgba(0,0,0,0.3);
      border: 1px solid #444;
      color: #eee;
      padding: 3px 5px;
      border-radius: 4px;
    }

    .presets {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      margin: 15px 0;
    }

    button {
      background: #e94560;
      color: white;
      border: none;
      padding: 10px 20px;
      font-size: 14px;
      cursor: pointer;
      border-radius: 6px;
      transition: all 0.2s;
    }
    button:hover { background: #ff6b6b; }
    button:disabled { background: #444; cursor: not-allowed; }
    button.preset { background: #2a2a4e; border: 1px solid #4ecdc4; }
    button.preset:hover { background: #3a3a6e; }
    button.preset.active { background: #4ecdc4; color: #1a1a2e; }

    .controls {
      display: flex;
      gap: 10px;
      margin: 20px 0;
      flex-wrap: wrap;
    }

    #status {
      padding: 10px;
      background: rgba(0,0,0,0.2);
      border-radius: 8px;
      font-size: 14px;
      color: #888;
    }

    .info-box {
      background: rgba(78, 205, 196, 0.1);
      border-left: 4px solid #4ecdc4;
      padding: 15px;
      margin: 15px 0;
      border-radius: 0 8px 8px 0;
    }

    .chain-description {
      margin-top: 15px;
      padding: 10px;
      background: rgba(0,0,0,0.2);
      border-radius: 8px;
      font-family: monospace;
      font-size: 13px;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>Audio Signal Flow</h1>
    <p class="subtitle">Drag effects to reorder - hear how the chain changes the sound</p>

    <div class="section">
      <h2>Signal Chain</h2>

      <div class="signal-chain" id="signalChain">
        <div class="node source" data-type="source">
          <div class="name">Synth</div>
          <div class="type">SOURCE</div>
        </div>
        <div class="arrow">→</div>
        <!-- Effects will be inserted here -->
        <div class="node output" data-type="output">
          <div class="name">Output</div>
          <div class="type">SPEAKERS</div>
        </div>
      </div>

      <div class="chain-description" id="chainDescription">
        Synth → Output
      </div>

      <div class="controls">
        <button id="playBtn">Play Note</button>
        <button id="playChord">Play Chord</button>
        <button id="loopBtn">Start Loop</button>
        <button id="stopBtn" disabled>Stop</button>
      </div>

      <div id="status">Click Play to hear the chain</div>
    </div>

    <div class="section">
      <h2>Available Effects</h2>
      <p>Click to add/remove from chain:</p>

      <div class="presets" id="effectButtons">
        <button class="preset" data-effect="filter">Filter (Lowpass)</button>
        <button class="preset" data-effect="reverb">Reverb</button>
        <button class="preset" data-effect="delay">Delay</button>
        <button class="preset" data-effect="distortion">Distortion</button>
        <button class="preset" data-effect="bitcrusher">Bitcrusher</button>
      </div>
    </div>

    <div class="section">
      <h2>Preset Chains</h2>
      <div class="presets">
        <button class="preset" id="presetDry">Dry (No Effects)</button>
        <button class="preset" id="presetBasic">Basic Lofi</button>
        <button class="preset" id="presetDusty">Dusty Vinyl</button>
        <button class="preset" id="presetTape">Tape Degradation</button>
      </div>
    </div>

    <div class="info-box">
      <strong>Try This:</strong> Add Filter and Reverb. Play a note. Now drag Filter AFTER Reverb.
      Notice how the reverb tail also gets filtered - creating that dusty lofi sound.
    </div>
  </div>

  <script>
    // Effect definitions
    const effectDefs = {
      filter: {
        name: 'Filter',
        create: () => new Tone.Filter(800, 'lowpass'),
        params: { frequency: 800 }
      },
      reverb: {
        name: 'Reverb',
        create: async () => {
          const rev = new Tone.Reverb({ decay: 2.5, wet: 0.4 });
          await rev.generate();
          return rev;
        },
        params: { wet: 0.4 }
      },
      delay: {
        name: 'Delay',
        create: () => new Tone.FeedbackDelay('8n', 0.3),
        params: { wet: 0.3 }
      },
      distortion: {
        name: 'Distortion',
        create: () => new Tone.Distortion(0.3),
        params: { distortion: 0.3 }
      },
      bitcrusher: {
        name: 'Bitcrusher',
        create: () => new Tone.BitCrusher(6),
        params: { bits: 6 }
      }
    };

    // Current chain state
    let activeEffects = [];
    let effectInstances = {};
    let synth = null;
    let loop = null;
    let isPlaying = false;

    // Initialize synth
    function createSynth() {
      if (synth) synth.dispose();
      synth = new Tone.PolySynth(Tone.Synth, {
        oscillator: { type: 'triangle' },
        envelope: { attack: 0.1, decay: 0.3, sustain: 0.4, release: 1 }
      });
      synth.volume.value = -12;
    }

    // Rebuild the audio chain
    async function rebuildChain() {
      // Dispose old instances
      Object.values(effectInstances).forEach(fx => fx.dispose());
      effectInstances = {};

      createSynth();

      if (activeEffects.length === 0) {
        synth.toDestination();
      } else {
        // Create effect instances
        let lastNode = synth;
        for (const effectId of activeEffects) {
          const def = effectDefs[effectId];
          const instance = await def.create();
          effectInstances[effectId] = instance;
          lastNode.connect(instance);
          lastNode = instance;
        }
        lastNode.toDestination();
      }

      updateChainDisplay();
    }

    // Update visual chain
    function updateChainDisplay() {
      const chain = document.getElementById('signalChain');
      const source = chain.querySelector('.source');
      const output = chain.querySelector('.output');

      // Remove existing effect nodes
      chain.querySelectorAll('.node.effect, .arrow:not(:first-of-type)').forEach(el => el.remove());

      // Add effect nodes
      let insertBefore = output.previousElementSibling; // The arrow before output

      activeEffects.forEach((effectId, idx) => {
        const def = effectDefs[effectId];

        const node = document.createElement('div');
        node.className = 'node effect';
        node.dataset.effect = effectId;
        node.draggable = true;
        node.innerHTML = `
          <div class="name">${def.name}</div>
          <div class="type">EFFECT</div>
        `;

        const arrow = document.createElement('div');
        arrow.className = 'arrow';
        arrow.textContent = '→';

        chain.insertBefore(node, output);
        chain.insertBefore(arrow, output);

        // Drag events
        node.addEventListener('dragstart', handleDragStart);
        node.addEventListener('dragend', handleDragEnd);
        node.addEventListener('dragover', handleDragOver);
        node.addEventListener('drop', handleDrop);
      });

      // Update description
      const names = ['Synth', ...activeEffects.map(id => effectDefs[id].name), 'Output'];
      document.getElementById('chainDescription').textContent = names.join(' → ');

      // Update buttons
      document.querySelectorAll('#effectButtons .preset').forEach(btn => {
        btn.classList.toggle('active', activeEffects.includes(btn.dataset.effect));
      });
    }

    // Drag and drop handlers
    let draggedEffect = null;

    function handleDragStart(e) {
      draggedEffect = e.target.dataset.effect;
      e.target.classList.add('dragging');
    }

    function handleDragEnd(e) {
      e.target.classList.remove('dragging');
      draggedEffect = null;
    }

    function handleDragOver(e) {
      e.preventDefault();
    }

    function handleDrop(e) {
      e.preventDefault();
      const targetEffect = e.target.closest('.node.effect')?.dataset.effect;
      if (targetEffect && draggedEffect && targetEffect !== draggedEffect) {
        // Swap positions
        const fromIdx = activeEffects.indexOf(draggedEffect);
        const toIdx = activeEffects.indexOf(targetEffect);
        activeEffects.splice(fromIdx, 1);
        activeEffects.splice(toIdx, 0, draggedEffect);
        rebuildChain();
      }
    }

    // Toggle effect
    function toggleEffect(effectId) {
      const idx = activeEffects.indexOf(effectId);
      if (idx >= 0) {
        activeEffects.splice(idx, 1);
      } else {
        activeEffects.push(effectId);
      }
      rebuildChain();
    }

    // Effect button clicks
    document.querySelectorAll('#effectButtons .preset').forEach(btn => {
      btn.addEventListener('click', () => toggleEffect(btn.dataset.effect));
    });

    // Preset chains
    document.getElementById('presetDry').addEventListener('click', async () => {
      activeEffects = [];
      await rebuildChain();
    });

    document.getElementById('presetBasic').addEventListener('click', async () => {
      activeEffects = ['filter', 'reverb'];
      await rebuildChain();
    });

    document.getElementById('presetDusty').addEventListener('click', async () => {
      activeEffects = ['bitcrusher', 'filter', 'reverb', 'delay'];
      await rebuildChain();
    });

    document.getElementById('presetTape').addEventListener('click', async () => {
      activeEffects = ['distortion', 'filter', 'reverb'];
      await rebuildChain();
    });

    // Play controls
    document.getElementById('playBtn').addEventListener('click', async () => {
      await Tone.start();
      if (!synth) await rebuildChain();
      synth.triggerAttackRelease('C4', '4n');
      document.getElementById('status').textContent = 'Playing C4 through chain...';
    });

    document.getElementById('playChord').addEventListener('click', async () => {
      await Tone.start();
      if (!synth) await rebuildChain();
      synth.triggerAttackRelease(['D3', 'F3', 'A3', 'C4'], '2n');
      document.getElementById('status').textContent = 'Playing Dm7 chord through chain...';
    });

    document.getElementById('loopBtn').addEventListener('click', async () => {
      await Tone.start();
      if (!synth) await rebuildChain();

      const chords = [
        ['D3', 'F3', 'A3', 'C4'],
        ['G3', 'B3', 'D4', 'F4'],
        ['C3', 'E3', 'G3', 'B3'],
        ['A2', 'C3', 'E3', 'G3']
      ];
      let idx = 0;

      Tone.Transport.bpm.value = 72;

      loop = new Tone.Loop((time) => {
        synth.triggerAttackRelease(chords[idx], '2n', time, 0.4);
        idx = (idx + 1) % chords.length;
      }, '2n').start(0);

      Tone.Transport.start();
      isPlaying = true;
      document.getElementById('loopBtn').disabled = true;
      document.getElementById('stopBtn').disabled = false;
      document.getElementById('status').textContent = 'Loop playing through chain...';
    });

    document.getElementById('stopBtn').addEventListener('click', () => {
      Tone.Transport.stop();
      if (loop) { loop.dispose(); loop = null; }
      isPlaying = false;
      document.getElementById('loopBtn').disabled = false;
      document.getElementById('stopBtn').disabled = true;
      document.getElementById('status').textContent = 'Stopped';
    });

    // Initialize
    rebuildChain();
  </script>
</body>
</html>
