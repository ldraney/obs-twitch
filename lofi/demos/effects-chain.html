<!DOCTYPE html>
<html>
<head>
  <title>Effects Chain - Demo</title>
  <script src="https://unpkg.com/tone@14"></script>
  <style>
    * { box-sizing: border-box; }
    body {
      background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
      color: #eee;
      font-family: 'Segoe UI', sans-serif;
      min-height: 100vh;
      margin: 0;
      padding: 20px;
    }
    .container { max-width: 1100px; margin: 0 auto; }
    h1 { color: #e94560; margin-bottom: 10px; }
    h2 { color: #4ecdc4; margin-top: 30px; margin-bottom: 15px; }
    .subtitle { color: #888; margin-bottom: 30px; }

    .section {
      background: rgba(255,255,255,0.05);
      border-radius: 12px;
      padding: 20px;
      margin: 20px 0;
    }

    /* Preset buttons */
    .presets {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      margin: 15px 0;
    }
    .preset-btn {
      background: rgba(78, 205, 196, 0.15);
      color: #4ecdc4;
      border: 2px solid #4ecdc4;
      padding: 12px 20px;
      font-size: 14px;
      cursor: pointer;
      border-radius: 8px;
      transition: all 0.2s;
    }
    .preset-btn:hover {
      background: rgba(78, 205, 196, 0.3);
      transform: translateY(-2px);
    }
    .preset-btn.active {
      background: #4ecdc4;
      color: #1a1a2e;
      font-weight: bold;
    }

    /* Signal flow visualization */
    .signal-flow {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 20px;
      background: rgba(0,0,0,0.3);
      border-radius: 8px;
      overflow-x: auto;
      min-height: 140px;
    }

    .flow-node {
      background: #2a2a4e;
      border: 2px solid #4ecdc4;
      border-radius: 8px;
      padding: 12px 16px;
      min-width: 100px;
      text-align: center;
      transition: all 0.3s;
      position: relative;
    }
    .flow-node.source { border-color: #e94560; background: rgba(233, 69, 96, 0.2); }
    .flow-node.output { border-color: #4ecdc4; background: rgba(78, 205, 196, 0.2); }
    .flow-node.effect { cursor: pointer; }
    .flow-node.effect:hover { border-color: #e94560; transform: scale(1.02); }
    .flow-node.bypassed {
      opacity: 0.4;
      border-style: dashed;
      background: rgba(100,100,100,0.1);
    }
    .flow-node .name { font-weight: bold; font-size: 14px; margin-bottom: 4px; }
    .flow-node .param { font-size: 11px; color: #888; }
    .flow-node .bypass-indicator {
      position: absolute;
      top: -8px;
      right: -8px;
      background: #e94560;
      color: white;
      font-size: 10px;
      padding: 2px 6px;
      border-radius: 10px;
      display: none;
    }
    .flow-node.bypassed .bypass-indicator { display: block; }

    .flow-arrow {
      color: #4ecdc4;
      font-size: 20px;
      flex-shrink: 0;
      transition: opacity 0.3s;
    }
    .flow-arrow.dim { opacity: 0.3; }

    /* Controls */
    .controls-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 15px;
      margin: 15px 0;
    }

    .control {
      background: rgba(0,0,0,0.2);
      padding: 15px;
      border-radius: 8px;
    }
    .control label {
      display: block;
      color: #888;
      font-size: 12px;
      margin-bottom: 5px;
    }
    .control .value {
      color: #e94560;
      font-weight: bold;
      float: right;
    }
    .control input[type="range"] {
      width: 100%;
      margin-top: 5px;
      accent-color: #4ecdc4;
    }

    /* Play controls */
    .play-controls {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      margin: 15px 0;
    }

    button {
      background: #e94560;
      color: white;
      border: none;
      padding: 12px 24px;
      font-size: 14px;
      cursor: pointer;
      border-radius: 8px;
      transition: all 0.2s;
    }
    button:hover { background: #ff6b6b; transform: scale(1.02); }
    button:active { transform: scale(0.98); }
    button:disabled { background: #444; cursor: not-allowed; transform: none; }

    #status {
      padding: 12px;
      background: rgba(0,0,0,0.2);
      border-radius: 8px;
      font-size: 14px;
      color: #888;
      text-align: center;
    }

    .info-box {
      background: rgba(78, 205, 196, 0.1);
      border-left: 4px solid #4ecdc4;
      padding: 15px;
      margin: 15px 0;
      border-radius: 0 8px 8px 0;
    }
    .info-box strong { color: #4ecdc4; }

    .tip-box {
      background: rgba(233, 69, 96, 0.1);
      border-left: 4px solid #e94560;
      padding: 15px;
      margin: 15px 0;
      border-radius: 0 8px 8px 0;
    }
    .tip-box strong { color: #e94560; }

    /* Chain description */
    .chain-code {
      background: rgba(0,0,0,0.4);
      padding: 15px;
      border-radius: 8px;
      font-family: 'Consolas', 'Monaco', monospace;
      font-size: 13px;
      color: #4ecdc4;
      overflow-x: auto;
    }

    /* Effect bypass grid */
    .bypass-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
      gap: 10px;
      margin: 15px 0;
    }
    .bypass-toggle {
      display: flex;
      align-items: center;
      gap: 8px;
      background: rgba(0,0,0,0.2);
      padding: 10px;
      border-radius: 6px;
    }
    .bypass-toggle input[type="checkbox"] {
      width: 18px;
      height: 18px;
      accent-color: #4ecdc4;
    }
    .bypass-toggle label {
      font-size: 13px;
      cursor: pointer;
    }
    .bypass-toggle.disabled label {
      color: #666;
      text-decoration: line-through;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>Effects Chain</h1>
    <p class="subtitle">Capstone demo - see how all effects work together in a lofi signal chain</p>

    <div class="section">
      <h2>1. Choose a Preset Chain</h2>
      <p>Each preset demonstrates a different lofi aesthetic:</p>

      <div class="presets">
        <button class="preset-btn active" data-preset="clean">Clean (No Effects)</button>
        <button class="preset-btn" data-preset="basic">Basic Lofi</button>
        <button class="preset-btn" data-preset="dusty">Dusty Vinyl</button>
        <button class="preset-btn" data-preset="tape">Tape Warmth</button>
      </div>

      <div class="tip-box" id="presetDescription">
        <strong>Clean:</strong> Dry signal with no effects. Use this as a reference to hear what the effects add.
      </div>
    </div>

    <div class="section">
      <h2>2. Signal Flow</h2>
      <p>Click any effect to bypass it and hear the difference:</p>

      <div class="signal-flow" id="signalFlow">
        <!-- Dynamically populated -->
      </div>

      <div class="chain-code" id="chainCode">
        synth.toDestination();
      </div>
    </div>

    <div class="section">
      <h2>3. Effect Controls</h2>
      <p>Toggle individual effects and adjust the master mix:</p>

      <div class="bypass-grid" id="bypassGrid">
        <!-- Dynamically populated -->
      </div>

      <div class="controls-grid">
        <div class="control">
          <label>Master Volume <span class="value" id="volumeVal">-6 dB</span></label>
          <input type="range" id="masterVolume" min="-24" max="0" step="1" value="-6">
        </div>
        <div class="control">
          <label>Filter Cutoff <span class="value" id="filterVal">800 Hz</span></label>
          <input type="range" id="filterCutoff" min="200" max="3000" step="50" value="800">
        </div>
        <div class="control">
          <label>Reverb Amount <span class="value" id="reverbVal">35%</span></label>
          <input type="range" id="reverbWet" min="0" max="100" step="5" value="35">
        </div>
        <div class="control">
          <label>Delay Amount <span class="value" id="delayVal">20%</span></label>
          <input type="range" id="delayWet" min="0" max="100" step="5" value="20">
        </div>
      </div>
    </div>

    <div class="section">
      <h2>4. Play & Listen</h2>

      <div class="play-controls">
        <button id="playChord">Play Chord</button>
        <button id="playProgression">Play Progression</button>
        <button id="startLoop">Start Loop</button>
        <button id="stopBtn" disabled>Stop</button>
      </div>

      <div id="status">Click a button to start - compare the presets!</div>
    </div>

    <div class="info-box">
      <strong>Try This:</strong> Start with "Clean", then switch to "Basic Lofi" while playing.
      Hear how the filter and reverb transform the raw sound. Then try bypassing the filter to hear
      bright reverb vs filtered reverb.
    </div>
  </div>

  <script>
    // Preset definitions
    const presets = {
      clean: {
        name: 'Clean',
        description: '<strong>Clean:</strong> Dry signal with no effects. Use this as a reference to hear what the effects add.',
        effects: [],
        code: 'synth.toDestination();'
      },
      basic: {
        name: 'Basic Lofi',
        description: '<strong>Basic Lofi:</strong> Filter removes harsh highs, reverb adds space. The foundation of any lofi sound.',
        effects: ['filter', 'reverb'],
        code: 'synth.chain(filter, reverb, Tone.Destination);'
      },
      dusty: {
        name: 'Dusty Vinyl',
        description: '<strong>Dusty Vinyl:</strong> BitCrusher adds digital grit, heavy filtering, reverb for space, delay for echoes. That old record feel.',
        effects: ['bitcrusher', 'filter', 'reverb', 'delay'],
        code: 'synth.chain(bitcrusher, filter, reverb, delay, Tone.Destination);'
      },
      tape: {
        name: 'Tape Warmth',
        description: '<strong>Tape Warmth:</strong> Chorus for pitch wobble, light distortion for saturation, filter to tame, reverb for depth. Analog nostalgia.',
        effects: ['chorus', 'distortion', 'filter', 'reverb'],
        code: 'synth.chain(chorus, distortion, filter, reverb, Tone.Destination);'
      }
    };

    // Effect definitions with create functions
    const effectDefs = {
      chorus: {
        name: 'Chorus',
        param: 'depth: 0.3',
        create: () => {
          const ch = new Tone.Chorus(1.5, 2.5, 0.3);
          ch.start();
          return ch;
        }
      },
      bitcrusher: {
        name: 'BitCrusher',
        param: 'bits: 8',
        create: () => new Tone.BitCrusher(8)
      },
      distortion: {
        name: 'Distortion',
        param: 'amount: 0.2',
        create: () => new Tone.Distortion(0.2)
      },
      filter: {
        name: 'Filter',
        param: '800 Hz',
        create: () => {
          const f = new Tone.Filter(800, 'lowpass');
          f.rolloff = -24;
          return f;
        }
      },
      reverb: {
        name: 'Reverb',
        param: 'wet: 0.35',
        create: async () => {
          const r = new Tone.Reverb({ decay: 2.5, wet: 0.35 });
          await r.generate();
          return r;
        }
      },
      delay: {
        name: 'Delay',
        param: 'wet: 0.2',
        create: () => {
          const d = new Tone.FeedbackDelay('8n.', 0.25);
          d.wet.value = 0.2;
          return d;
        }
      }
    };

    // State
    let currentPreset = 'clean';
    let synth = null;
    let effectInstances = {};
    let bypassedEffects = new Set();
    let loop = null;
    let isPlaying = false;
    let master = null;

    // Chord progression
    const chords = [
      ['D3', 'F3', 'A3', 'C4'],  // Dm7
      ['G3', 'B3', 'D4', 'F4'],  // Gmaj7
      ['C3', 'E3', 'G3', 'B3'],  // Cmaj7
      ['A2', 'C3', 'E3', 'G3']   // Am7
    ];

    // Initialize
    async function init() {
      await buildChain();
      updateUI();
    }

    // Build the audio chain based on current preset and bypasses
    async function buildChain() {
      // Dispose old instances
      if (synth) synth.dispose();
      if (master) master.dispose();
      Object.values(effectInstances).forEach(fx => {
        if (fx && fx.dispose) fx.dispose();
      });
      effectInstances = {};

      // Create synth
      synth = new Tone.PolySynth(Tone.Synth, {
        oscillator: { type: 'triangle' },
        envelope: {
          attack: 0.08,
          decay: 0.3,
          sustain: 0.4,
          release: 1.2
        }
      });
      synth.volume.value = -12;

      // Create master volume
      master = new Tone.Volume(parseInt(document.getElementById('masterVolume').value));

      const preset = presets[currentPreset];
      const activeEffects = preset.effects.filter(id => !bypassedEffects.has(id));

      if (activeEffects.length === 0) {
        synth.connect(master);
        master.toDestination();
      } else {
        // Create effect instances
        let lastNode = synth;
        for (const effectId of activeEffects) {
          const def = effectDefs[effectId];
          const instance = await def.create();
          effectInstances[effectId] = instance;

          // Apply current control values
          if (effectId === 'filter') {
            instance.frequency.value = parseInt(document.getElementById('filterCutoff').value);
          } else if (effectId === 'reverb') {
            instance.wet.value = parseInt(document.getElementById('reverbWet').value) / 100;
          } else if (effectId === 'delay') {
            instance.wet.value = parseInt(document.getElementById('delayWet').value) / 100;
          }

          lastNode.connect(instance);
          lastNode = instance;
        }
        lastNode.connect(master);
        master.toDestination();
      }

      updateSignalFlow();
      updateBypassGrid();
    }

    // Update the signal flow visualization
    function updateSignalFlow() {
      const container = document.getElementById('signalFlow');
      const preset = presets[currentPreset];

      let html = `
        <div class="flow-node source">
          <div class="name">Synth</div>
          <div class="param">triangle</div>
        </div>
      `;

      if (preset.effects.length > 0) {
        html += '<div class="flow-arrow">&#8594;</div>';
      }

      preset.effects.forEach((effectId, idx) => {
        const def = effectDefs[effectId];
        const isBypassed = bypassedEffects.has(effectId);
        const bypassClass = isBypassed ? 'bypassed' : '';

        html += `
          <div class="flow-node effect ${bypassClass}" data-effect="${effectId}">
            <div class="name">${def.name}</div>
            <div class="param">${def.param}</div>
            <div class="bypass-indicator">OFF</div>
          </div>
        `;

        if (idx < preset.effects.length - 1) {
          const nextBypassed = bypassedEffects.has(preset.effects[idx + 1]);
          const arrowClass = isBypassed || nextBypassed ? 'dim' : '';
          html += `<div class="flow-arrow ${arrowClass}">&#8594;</div>`;
        }
      });

      const lastBypassed = preset.effects.length > 0 &&
                           bypassedEffects.has(preset.effects[preset.effects.length - 1]);
      html += `
        <div class="flow-arrow ${lastBypassed ? 'dim' : ''}">&#8594;</div>
        <div class="flow-node output">
          <div class="name">Output</div>
          <div class="param">speakers</div>
        </div>
      `;

      container.innerHTML = html;

      // Add click handlers for bypass
      container.querySelectorAll('.flow-node.effect').forEach(node => {
        node.addEventListener('click', () => toggleBypass(node.dataset.effect));
      });

      // Update code display
      updateCodeDisplay();
    }

    // Update code display
    function updateCodeDisplay() {
      const preset = presets[currentPreset];
      const activeEffects = preset.effects.filter(id => !bypassedEffects.has(id));

      let code;
      if (activeEffects.length === 0) {
        code = 'synth.toDestination();';
      } else {
        const names = activeEffects.map(id => effectDefs[id].name.toLowerCase());
        code = `synth.chain(${names.join(', ')}, Tone.Destination);`;
      }

      document.getElementById('chainCode').textContent = code;
    }

    // Update bypass grid
    function updateBypassGrid() {
      const container = document.getElementById('bypassGrid');
      const preset = presets[currentPreset];

      if (preset.effects.length === 0) {
        container.innerHTML = '<p style="color: #888; margin: 0;">No effects in this preset</p>';
        return;
      }

      let html = '';
      preset.effects.forEach(effectId => {
        const def = effectDefs[effectId];
        const isBypassed = bypassedEffects.has(effectId);
        const disabledClass = isBypassed ? 'disabled' : '';

        html += `
          <div class="bypass-toggle ${disabledClass}">
            <input type="checkbox" id="bypass-${effectId}" ${!isBypassed ? 'checked' : ''}>
            <label for="bypass-${effectId}">${def.name}</label>
          </div>
        `;
      });

      container.innerHTML = html;

      // Add handlers
      preset.effects.forEach(effectId => {
        document.getElementById(`bypass-${effectId}`).addEventListener('change', (e) => {
          if (!e.target.checked) {
            bypassedEffects.add(effectId);
          } else {
            bypassedEffects.delete(effectId);
          }
          buildChain();
        });
      });
    }

    // Toggle bypass for an effect
    function toggleBypass(effectId) {
      if (bypassedEffects.has(effectId)) {
        bypassedEffects.delete(effectId);
      } else {
        bypassedEffects.add(effectId);
      }
      buildChain();
    }

    // Update all UI elements
    function updateUI() {
      // Update preset buttons
      document.querySelectorAll('.preset-btn').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.preset === currentPreset);
      });

      // Update description
      document.getElementById('presetDescription').innerHTML = presets[currentPreset].description;

      updateSignalFlow();
      updateBypassGrid();
    }

    // Play a single chord
    async function playChord() {
      await Tone.start();
      synth.triggerAttackRelease(chords[0], '2n');
      document.getElementById('status').textContent = 'Playing Dm7 chord...';
    }

    // Play the progression once
    async function playProgression() {
      await Tone.start();
      let idx = 0;
      const interval = setInterval(() => {
        if (idx >= chords.length) {
          clearInterval(interval);
          document.getElementById('status').textContent = 'Progression complete';
          return;
        }
        synth.triggerAttackRelease(chords[idx], '2n', undefined, 0.5);
        document.getElementById('status').textContent = `Playing chord ${idx + 1} of 4...`;
        idx++;
      }, 1200);
    }

    // Start loop
    async function startLoop() {
      await Tone.start();

      if (loop) loop.dispose();

      let idx = 0;
      Tone.Transport.bpm.value = 72;

      loop = new Tone.Loop((time) => {
        synth.triggerAttackRelease(chords[idx], '2n', time, 0.5);
        idx = (idx + 1) % chords.length;
      }, '2n').start(0);

      Tone.Transport.start();
      isPlaying = true;

      document.getElementById('startLoop').disabled = true;
      document.getElementById('stopBtn').disabled = false;
      document.getElementById('status').textContent = 'Looping chord progression... Switch presets to hear the difference!';
    }

    // Stop
    function stopLoop() {
      Tone.Transport.stop();
      if (loop) { loop.dispose(); loop = null; }
      isPlaying = false;

      document.getElementById('startLoop').disabled = false;
      document.getElementById('stopBtn').disabled = true;
      document.getElementById('status').textContent = 'Stopped';
    }

    // Event listeners - Presets
    document.querySelectorAll('.preset-btn').forEach(btn => {
      btn.addEventListener('click', async () => {
        currentPreset = btn.dataset.preset;
        bypassedEffects.clear(); // Reset bypasses when switching presets
        await buildChain();
        updateUI();
      });
    });

    // Event listeners - Play controls
    document.getElementById('playChord').addEventListener('click', playChord);
    document.getElementById('playProgression').addEventListener('click', playProgression);
    document.getElementById('startLoop').addEventListener('click', startLoop);
    document.getElementById('stopBtn').addEventListener('click', stopLoop);

    // Event listeners - Controls
    document.getElementById('masterVolume').addEventListener('input', (e) => {
      const val = parseInt(e.target.value);
      document.getElementById('volumeVal').textContent = val + ' dB';
      if (master) master.volume.value = val;
    });

    document.getElementById('filterCutoff').addEventListener('input', (e) => {
      const val = parseInt(e.target.value);
      document.getElementById('filterVal').textContent = val + ' Hz';
      if (effectInstances.filter) {
        effectInstances.filter.frequency.value = val;
      }
      // Update param display in flow
      effectDefs.filter.param = val + ' Hz';
      updateSignalFlow();
    });

    document.getElementById('reverbWet').addEventListener('input', (e) => {
      const val = parseInt(e.target.value);
      document.getElementById('reverbVal').textContent = val + '%';
      if (effectInstances.reverb) {
        effectInstances.reverb.wet.value = val / 100;
      }
      effectDefs.reverb.param = 'wet: ' + (val / 100).toFixed(2);
      updateSignalFlow();
    });

    document.getElementById('delayWet').addEventListener('input', (e) => {
      const val = parseInt(e.target.value);
      document.getElementById('delayVal').textContent = val + '%';
      if (effectInstances.delay) {
        effectInstances.delay.wet.value = val / 100;
      }
      effectDefs.delay.param = 'wet: ' + (val / 100).toFixed(2);
      updateSignalFlow();
    });

    // Initialize on load
    init();
  </script>
</body>
</html>
